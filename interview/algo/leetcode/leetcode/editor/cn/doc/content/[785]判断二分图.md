存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：

<ul> 
 <li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li> 
 <li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li> 
 <li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li> 
 <li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li> 
</ul>

<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>

<p>如果图是二分图，返回 <code>true</code><em> </em>；否则，返回 <code>false</code> 。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" style="width: 222px; height: 222px;" /> 
<pre>
<strong>输入：</strong>graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
<strong>输出：</strong>false
<strong>解释：</strong><span><code>不能将节点分割成两个独立的子集，</code></span>以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</pre>

<p><strong>示例 2：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" style="width: 222px; height: 222px;" /> 
<pre>
<strong>输入：</strong>graph = [[1,3],[0,2],[1,3],[0,2]]
<strong>输出：</strong>true
<strong>解释：</strong><span><code>可以将节点分成两组: {0, 2} 和 {1, 3} 。</code></span></pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>graph.length == n</code></li> 
 <li><code>1 &lt;= n &lt;= 100</code></li> 
 <li><code>0 &lt;= graph[u].length &lt; n</code></li> 
 <li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li> 
 <li><code>graph[u]</code> 不会包含 <code>u</code></li> 
 <li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li> 
 <li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>深度优先搜索 | 广度优先搜索 | 并查集 | 图</details><br>

<div>👍 537, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：网站新增大量习题，新增排序算法专题及可视化，具体请查看 [网站更新日志](https://labuladong.online/algo/changelog/website/)~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=is-graph-bipartite" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

二分图判定问题等同于图论的「双色问题」：

**给你一幅「图」，请你用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同，你能做到吗**？

如果能成功对整幅图染色，则说明这是一幅二分图，否则就不是二分图。

思路也很简单，遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同。

- **详细题解**：
  - [二分图判定算法](https://labuladong.online/algo/data-structure/bipartite-graph/)

</div>

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution {
    // 记录图是否符合二分图性质
    private:
        bool ok = true;
        // 记录图中节点的颜色，false 和 true 代表两种不同颜色
        vector<bool> color;
        // 记录图中节点是否被访问过
        vector<bool> visited;

        // DFS 遍历框架
        void traverse(const vector<vector<int>>& graph, int v) {
            // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
            if (!ok) return;

            visited[v] = true;
            for (int w : graph[v]) {
                if (!visited[w]) {
                    // 相邻节点 w 没有被访问过
                    // 那么应该给节点 w 涂上和节点 v 不同的颜色
                    color[w] = !color[v];
                    // 继续遍历 w
                    traverse(graph, w);
                } else {
                    // 相邻节点 w 已经被访问过
                    // 根据 v 和 w 的颜色判断是否是二分图
                    if (color[w] == color[v]) {
                        // 若相同，则此图不是二分图
                        ok = false;
                    }
                }
            }
        }

    public:
        // 主函数，输入邻接表，判断是否是二分图
        bool isBipartite(vector<vector<int>>& graph) {
            int n = graph.size();
            color = vector<bool>(n);
            visited = vector<bool>(n);
            // 因为图不一定是联通的，可能存在多个子图
            // 所以要把每个节点都作为起点进行一次遍历
            // 如果发现任何一个子图不是二分图，整幅图都不算二分图
            for (int v = 0; v < n; v++) {
                if (!visited[v]) {
                    traverse(graph, v);
                }
            }
            return ok;
        }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution:
    # 记录图是否符合二分图性质
    # 记录图中节点的颜色，false 和 true 代表两种不同颜色
    # 记录图中节点是否被访问过
    def __init__(self):
        self.ok = True
        self.color = None
        self.visited = None

    # 主函数，输入邻接表，判断是否是二分图
    def isBipartite(self, graph: List[List[int]]) -> bool:
        n = len(graph)
        self.color = [False] * n
        self.visited = [False] * n
        # 因为图不一定是联通的，可能存在多个子图
        # 所以要把每个节点都作为起点进行一次遍历
        # 如果发现任何一个子图不是二分图，整幅图都不算二分图
        for v in range(n):
            if not self.visited[v]:
                self.traverse(graph, v)
        return self.ok

    # DFS 遍历框架
    def traverse(self, graph: List[List[int]], v: int) -> None:
        # 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
        if not self.ok:
            return

        self.visited[v] = True
        for w in graph[v]:
            if not self.visited[w]:
                # 相邻节点 w 没有被访问过
                # 那么应该给节点 w 涂上和节点 v 不同的颜色
                self.color[w] = not self.color[v]
                # 继续遍历 w
                self.traverse(graph, w)
            else:
                # 相邻节点 w 已经被访问过
                # 根据 v 和 w 的颜色判断是否是二分图
                if self.color[w] == self.color[v]:
                    # 若相同，则此图不是二分图
                    self.ok = False
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {

    // 记录图是否符合二分图性质
    private boolean ok = true;
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    private boolean[] color;
    // 记录图中节点是否被访问过
    private boolean[] visited;

    // 主函数，输入邻接表，判断是否是二分图
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color = new boolean[n];
        visited = new boolean[n];
        // 因为图不一定是联通的，可能存在多个子图
        // 所以要把每个节点都作为起点进行一次遍历
        // 如果发现任何一个子图不是二分图，整幅图都不算二分图
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // DFS 遍历框架
    private void traverse(int[][] graph, int v) {
        // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
        if (!ok) return;

        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                // 相邻节点 w 没有被访问过
                // 那么应该给节点 w 涂上和节点 v 不同的颜色
                color[w] = !color[v];
                // 继续遍历 w
                traverse(graph, w);
            } else {
                // 相邻节点 w 已经被访问过
                // 根据 v 和 w 的颜色判断是否是二分图
                if (color[w] == color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                }
            }
        }
    }

}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

// 主函数，输入邻接表，判断是否是二分图
func isBipartite(graph [][]int) bool {
    n := len(graph)
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    color := make([]bool, n)
    // 记录图中节点是否被访问过
    visited := make([]bool, n)
    // 记录图是否符合二分图性质
    ok := true

    // 因为图不一定是联通的，可能存在多个子图
    // 所以要把每个节点都作为起点进行一次遍历
    // 如果发现任何一个子图不是二分图，整幅图都不算二分图
    for v := 0; v < n; v++ {
        if !visited[v] {
            traverse(graph, v, color, visited, &ok)
        }
    }
    return ok
}

// DFS 遍历框架
func traverse(graph [][]int, v int, color []bool, visited []bool, ok *bool) {
    // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
    if !*ok {
        return
    }

    visited[v] = true
    for _, w := range graph[v] {
        if !visited[w] {
            // 相邻节点 w 没有被访问过
            // 那么应该给节点 w 涂上和节点 v 不同的颜色
            color[w] = !color[v]
            // 继续遍历 w
            traverse(graph, w, color, visited, ok)
        } else {
            // 相邻节点 w 已经被访问过
            // 根据 v 和 w 的颜色判断是否是二分图
            if color[w] == color[v] {
                // 若相同，则此图不是二分图
                *ok = false
            }
        }
    }
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

var isBipartite = function(graph) {
    // 记录图是否符合二分图性质
    let ok = true;
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    let color = new Array(graph.length).fill(false);
    // 记录图中节点是否被访问过
    let visited = new Array(graph.length).fill(false);

    // DFS 遍历框架
    var traverse = function(graph, v) {
        // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
        if (!ok) return;

        visited[v] = true;
        for (let w of graph[v]) {
            if (!visited[w]) {
                // 相邻节点 w 没有被访问过
                // 那么应该给节点 w 涂上和节点 v 不同的颜色
                color[w] = !color[v];
                // 继续遍历 w
                traverse(graph, w);
            } else {
                // 相邻节点 w 已经被访问过
                // 根据 v 和 w 的颜色判断是否是二分图
                if (color[w] === color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                }
            }
        }
    };

    // 主函数，输入邻接表，判断是否是二分图
    let n = graph.length;
    // 因为图不一定是联通的，可能存在多个子图
    // 所以要把每个节点都作为起点进行一次遍历
    // 如果发现任何一个子图不是二分图，整幅图都不算二分图
    for (let v = 0; v < n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }

    return ok;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>👾👾 算法可视化 👾👾</strong></summary><div id="data_is-graph-bipartite" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_is-graph-bipartite"></div></div>
</details><hr /><br />

</div>

</details>
</div>

