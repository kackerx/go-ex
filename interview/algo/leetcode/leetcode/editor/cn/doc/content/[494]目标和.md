<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>

<p>向数组中的每个整数前添加&nbsp;<code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>

<ul> 
 <li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>"+2-1"</code> 。</li> 
</ul>

<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1,1,1,1], target = 3
<strong>输出：</strong>5
<strong>解释：</strong>一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1], target = 1
<strong>输出：</strong>1
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= nums.length &lt;= 20</code></li> 
 <li><code>0 &lt;= nums[i] &lt;= 1000</code></li> 
 <li><code>0 &lt;= sum(nums[i]) &lt;= 1000</code></li> 
 <li><code>-1000 &lt;= target &lt;= 1000</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数组 | 动态规划 | 回溯</details><br>

<div>👍 2018, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：网站新增大量习题，新增排序算法专题及可视化，具体请查看 [网站更新日志](https://labuladong.online/algo/changelog/website/)~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=target-sum" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

这题有多种解法，可以用回溯算法剪枝求解，也可以用转化成背包问题求解，这里用前者吧，容易理解一些，背包问题解法可以查看详细题解。

对于每一个 1，要么加正号，要么加负号，把所有情况穷举出来，即可计算结果。

- **详细题解**：
  - [背包问题的变体：目标和](https://labuladong.online/algo/dynamic-programming/target-sum/)

</div>

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

#include <unordered_map>
#include <vector>

class Solution {
public:
    int findTargetSumWays(std::vector<int>& nums, int target) {
        if (nums.empty()) return 0;
        return dp(nums, 0, target);
    }

    // 备忘录
    std::unordered_map<std::string, int> memo;

    int dp(std::vector<int>& nums, int i, int remain) {
        // base case
        if (i == nums.size()) {
            if (remain == 0) return 1;
            return 0;
        }
        // 把它俩转成字符串才能作为哈希表的键
        std::string key = std::to_string(i) + "," + std::to_string(remain);
        // 避免重复计算
        if (memo.count(key)) {
            return memo[key];
        }
        // 还是穷举
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // 记入备忘录
        memo[key] = result;
        return result;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution:
    def __init__(self):
        # 备忘录
        self.memo = {}

    def findTargetSumWays(self, nums, target):
        if len(nums) == 0:
            return 0
        return self.dp(nums, 0, target)

    def dp(self, nums, i, remain):
        # base case
        if i == len(nums):
            if remain == 0:
                return 1
            return 0
        # 把它俩转成字符串才能作为哈希表的键
        key = f"{i},{remain}"
        # 避免重复计算
        if key in self.memo:
            return self.memo[key]
        # 还是穷举
        result = self.dp(nums, i + 1, remain - nums[i]) + self.dp(nums, i + 1, remain + nums[i])
        # 记入备忘录
        self.memo[key] = result
        return result
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        return dp(nums, 0, target);
    }

    // 备忘录
    HashMap<String, Integer> memo = new HashMap<>();

    int dp(int[] nums, int i, int remain) {
        // base case
        if (i == nums.length) {
            if (remain == 0) return 1;
            return 0;
        }
        // 把它俩转成字符串才能作为哈希表的键
        String key = i + "," + remain;
        // 避免重复计算
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        // 还是穷举
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // 记入备忘录
        memo.put(key, result);
        return result;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

func findTargetSumWays(nums []int, target int) int {
    if len(nums) == 0 {
        return 0
    }
    memo := make(map[string]int)
    return dp(nums, 0, target, memo)
}

// 备忘录
func dp(nums []int, i int, remain int, memo map[string]int) int {
    // base case
    if i == len(nums) {
        if remain == 0 {
            return 1
        }
        return 0
    }
    // 把它俩转成字符串才能作为哈希表的键
    key := fmt.Sprintf("%d,%d", i, remain)
    // 避免重复计算
    if val, found := memo[key]; found {
        return val
    }
    // 还是穷举
    result := dp(nums, i+1, remain-nums[i], memo) + dp(nums, i+1, remain+nums[i], memo)
    // 记入备忘录
    memo[key] = result
    return result
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

// 传入一个整数数组和目标值target，求有多少种方法使得数组中的元素之和为target，每个元素可以选择加或者减
var findTargetSumWays = function (nums, target) {
  // 数组长度为0直接返回0
  if (nums.length === 0) return 0;

  // 备忘录哈希表，记录已经计算过的子问题的结果，避免重复计算
  const memo = new Map();

  // 递归函数
  const dp = (nums, i, remain) => {
    // 如果已经遍历到了数组的末尾，判断remain是否等于0，如果等于0则返回1，否则返回0
    if (i === nums.length) {
      if (remain === 0) return 1;
      return 0;
    }

    // 用i和remain作为键，判断是否已经计算过这个子问题，如果已经计算，则直接返回结果，否则继续计算
    const key = i + "," + remain;

    if (memo.has(key)) {
      return memo.get(key);
    }

    // 分别递归计算加上和减去当前元素后能够得到目标值的方案数量，相加得到当前子问题的解
    const result =
      dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);

    // 把计算结果存入备忘录
    memo.set(key, result);

    // 返回当前子问题的解
    return result;
  };

  // 从0开始遍历数组，计算从每个索引开始的子问题，最终得到问题的解
  return dp(nums, 0, target);
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🎃🎃 算法可视化 🎃🎃</strong></summary><div id="data_target-sum" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_target-sum"></div></div>
</details><hr /><br />

</div>

</details>
</div>

