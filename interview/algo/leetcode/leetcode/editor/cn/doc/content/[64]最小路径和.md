<p>给定一个包含非负整数的 <code><em>m</em>&nbsp;x&nbsp;<em>n</em></code>&nbsp;网格&nbsp;<code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>

<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>

<p>&nbsp;</p>

<p><strong class="example">示例 1：</strong></p> 
<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg" style="width: 242px; height: 242px;" /> 
<pre>
<strong>输入：</strong>grid = [[1,3,1],[1,5,1],[4,2,1]]
<strong>输出：</strong>7
<strong>解释：</strong>因为路径 1→3→1→1→1 的总和最小。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>grid = [[1,2,3],[4,5,6]]
<strong>输出：</strong>12
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>m == grid.length</code></li> 
 <li><code>n == grid[i].length</code></li> 
 <li><code>1 &lt;= m, n &lt;= 200</code></li> 
 <li><code>0 &lt;= grid[i][j] &lt;= 200</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数组 | 动态规划 | 矩阵</details><br>

<div>👍 1730, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：网站新增大量习题，新增排序算法专题及可视化，具体请查看 [网站更新日志](https://labuladong.online/algo/changelog/website/)~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=minimum-path-sum" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），肯定需要递归 + 备忘录，也就是动态规划技巧。

`dp` 函数的定义：**从左上角位置 `(0, 0)` 走到位置 `(i, j)` 的最小路径和为 `dp(grid, i, j)`**。

这样，`dp(grid, i, j)` 的值由 `dp(grid, i - 1, j)` 和 `dp(grid, i, j - 1)` 的值转移而来：

```java
dp(grid, i, j) = Math.min(
    dp(grid, i - 1, j),
    dp(grid, i, j - 1)
) + grid[i][j];
```

**详细题解**：
  - [动态规划之最小路径和](https://labuladong.online/algo/dynamic-programming/minimum-path-sum/)

</div>

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

#include <vector>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> memo;

    int minPathSum(std::vector<std::vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        // 构造备忘录，初始值全部设为 -1
        memo.resize(m, std::vector<int>(n, -1));

        return dp(grid, m - 1, n - 1);
    }

    int dp(std::vector<std::vector<int>>& grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return INT_MAX;
        }
        // 避免重复计算
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 将计算结果记入备忘录
        memo[i][j] = std::min(
                dp(grid, i - 1, j),
                dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution:
    def __init__(self):
        self.memo = None

    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        # 构造备忘录，初始值全部设为 -1
        self.memo = [[-1 for _ in range(n)] for _ in range(m)]

        return self.dp(grid, m - 1, n - 1)

    def dp(self, grid: List[List[int]], i: int, j: int) -> int:
        # base case
        if i == 0 and j == 0:
            return grid[0][0]
        if i < 0 or j < 0:
            return float('inf')
        # 避免重复计算
        if self.memo[i][j] != -1:
            return self.memo[i][j]
        # 将计算结果记入备忘录
        self.memo[i][j] = min(
            self.dp(grid, i - 1, j),
            self.dp(grid, i, j - 1)
        ) + grid[i][j]

        return self.memo[i][j]
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    int[][] memo;

    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 构造备忘录，初始值全部设为 -1
        memo = new int[m][n];
        for (int[] row : memo)
            Arrays.fill(row, -1);

        return dp(grid, m - 1, n - 1);
    }

    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return Integer.MAX_VALUE;
        }
        // 避免重复计算
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 将计算结果记入备忘录
        memo[i][j] = Math.min(
                dp(grid, i - 1, j),
                dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

var memo [][]int

func minPathSum(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    // 构造备忘录，初始值全部设为 -1
    memo = make([][]int, m)
    for i := range memo {
        memo[i] = make([]int, n)
        for j := range memo[i] {
            memo[i][j] = -1
        }
    }

    return dp(grid, m-1, n-1)
}

func dp(grid [][]int, i, j int) int {
    // base case
    if i == 0 && j == 0 {
        return grid[0][0]
    }
    if i < 0 || j < 0 {
        return int(^uint(0) >> 1) // Integer.MAX_VALUE equivalent in Go
    }
    // 避免重复计算
    if memo[i][j] != -1 {
        return memo[i][j]
    }
    // 将计算结果记入备忘录
    memo[i][j] = min(
        dp(grid, i-1, j),
        dp(grid, i, j-1),
    ) + grid[i][j]

    return memo[i][j]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

var minPathSum = function(grid) {
    let m = grid.length;
    let n = grid[0].length;
    // 构造备忘录，初始值全部设为 -1
    let memo = Array.from({ length: m }, () => Array(n).fill(-1));

    // @visualize status(i,j)
    var dp = function(grid, i, j, memo) {
        // base case
        if (i === 0 && j === 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return Number.MAX_VALUE;
        }
        // 避免重复计算
        if (memo[i][j] !== -1) {
            return memo[i][j];
        }
        // 将计算结果记入备忘录
        memo[i][j] = Math.min(
            dp(grid, i - 1, j, memo),
            dp(grid, i, j - 1, memo)
        ) + grid[i][j];

        return memo[i][j];
    }

    return dp(grid, m - 1, n - 1, memo);
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🥳🥳 算法可视化 🥳🥳</strong></summary><div id="data_minimum-path-sum" data="W3OiMRIhbBxAiOC/0WyEDRsHhnhvbGZA2DgARNokoB6ONxaN67tyxdyYC64BbQldAxG1QDoZMqBecmLfZ+5HnYf2BzGDtsTPAXd2NR2eLcLS1WfUDWrab/p3KnajvoiQKq0DxZODXD/wU76+M2wSgKd0vzzjzqK1pTrgr4JYycfhL7aYh9a8WXpAuvruRX6/zWKQnKRvw+PS1d/qZINQOamt8vfdedzvVoZip/KQg3xySmN+336fjQp1uMNcQeMIjyfWsTNdVX2D+OcHgGVevZ4/AaB/RoVoyWeFWaFXGRJuj19l14j1v2yW6Z0RMufASdBL02aI5NEBKl962eV2lo3//V6EcYSkPZ4gT6clr+r3HH2NMXQINNIBVGuicXERqkqujEvdF0LgYY0rY/VyvFB1lRFN1dM/cSMgj7SptRKKD/jNn/NtOP8eg8q+KBKsoXNKoDff5tswjnulv5XI5RYhbCg9rxPVgTJTK0000vr9oQ3SSnXWtROSTxVO+fGS3dz/XhTezn8/L39vISeqVOWkIwxcUf3J34vsCI641Nfwx785MHZ82igT4//q9cH89w9oN9hJ//28N9RsP4nZR+GQa1GzfaGEeg+nZ/pl/5Uop69Ca1glllfvb/qFsEh9wWgw+mMbUkYgS1NARHU4hlWD0pc+E3qO9bPjsR+RmUWKrA3Mbu458YjpqnXLD2tkbp4yicJ0Uf3Hjiu1MIxce5nGwhuV3LSvinW8+22vl0IRi+2oQ7oKqf36r95Q2X1uFC3YJMJbpQpsqiJZnWsYodCD6/zq+yzh30+6/id7bwCPdlX+RwT8GHlMLFapRF0F7+ImLaPfUUHmDQIfPzq276CSndZaVOaKUPQy58Q8hS29+ou3UZFmLhF7ae6q7Ooyv2KYiMLXFrSV+Y8RLMw7mQ4Gm0GI6ztPUNOeqs0zM7Ja1yRNZWLQXM1TduJ0kLjrS23r5xZPs8TuSlpmCAEYsxvfdUhuKItk5vzikCZ3ZJ78U95CKlqPgiknN9D7CNbRRAwQx9H+kifz8i4hn1y89uwuwP0czmNoDvFLMgS67i//grAbRgMLysOiYTD0CBtUyVy7SS1RDXjZTufxe0ZwfDyup7YOMSj6Xl8rA5/lBuyJiku7vukmDCpsuMG9df7iEh8WePUAeGwl6BjUWC3APhEINtzg3jofd/gBvPoAPCYPntNggNoc/qFDfd1F+RBa+5y8zwzid5wwt9BgfZSOqAYWqwDSB2ZLez+9ZBElv8GbB+YmMKy2LjPP9J0BJ6oMUtZ77TInDDPB+h0BIjL7ukq6lumy3yDIr7N3c9vAdhaCMYzNSMTEX+aa+pFPDqax+NDYIfEDdaB8D25zk79syKe1mdRWDzN4i2wsYrgyO2NeeeY3z0KA2hqLGN9qmsw8Q7eN/lP5xLBTjF/bd5tlocFhxq4LyJHxOUe9G1rt0IqRpDXhujYunurdCM81aPI1Z3144795Ju9fWLBvI+3LpmTniRuC8JIxa6lgmZ9hII0BhzYoiqgV3ST5TFWs+NlALTTpCDgvksxPdyThqjy8A9RREz/6vt/lX80Nrs5pZm0ad+bfcwPbTdfaGLAZcf2vTQ5iW4fDgmmRU3Pc72vdaL3PVyGy8deBfKlVOGM16cF4GTxPv6g9UnGfJTNX7vtG0w6Uif7B84PB2euafmK94pZT/sfMKabDIXBNIlrSPabKXsk+yX5KBy5zkzbsnEMoGY9wOHKH7kHVCrYkPvnkhvNVSn2HlRaTVDCSWT0ZhF3RulC5tMflYzYNgxzi+8nt1jlS4ZxEgoU/sfCREeaA1/xsuEknB0W2Ft1YUY5HXuzE3NW9gHMOIT093IYjhwiXxOaWBGxyw/kr31yUv455iE4FYyVbu56sIKkbnxcqt/Z4N8P9CwxyiF8ztVfnqArnJLIj3VRRQhc6gqRiELegwUn6UOV/50XOTn0GU/fhVupxiV1vD3LtIhwl3rT9l/XBF5A+xZftjFaoVYjC8342l1PtoLwetsR/OtZYYudotXsrH55qsqVy+kebQxtLDLyWQPO1dhtdmsecrhk6WiqAo2tXotl2OuYH7JTHSA04GSpdM6gmV/XOUl+oSIkNDcrbTc4lUJniKON9gWsSyZ2fonuo6hZLtyDdEumWqhxkSmdUHRaVDZ+KPpSEXOdPWeUxQsgtr6Mvncu7S9njYe4lwCCHeEPg30/n6ArnJLJHwlVUK7NUCtbCrneGLeDUZxBx9Joeg5eYAkpxULfR9KHSSgh5FIxk1lWV84Iyy0msxIII4jNPjXUOgHMS0ZupYjFMJwL6y30YY8F5ogR/WJtO8exITsZl5EZd8HCdNEszA+OfXLo0+vXKTMGVnWEsImctjmV+8OedotLYDkzr7U+UJ3mEnsFAV+KK53y3UjoeEOReErByaHmnjARyx/l0hpwwnaTxLE3OMRPTTYd7ER2ZxTZ8grKZPwCT1e55pcyaU5e+dsRa4HvsQMR1vxWc3Mi/242VJGwdHmdF577knfaW3CMZQEuZ74+JFUiySGlN0da4YgcRBNbbmkd0zszU4Dzn5shMwypDmTNtuWVgZ0yZVIhTHL0jsxvGEviMmLLZI+o+AuaEhuysKbMrhPsrGIqo0da4YociaFj3FQxLklsGdsal1Aap+xinN1ecAjY3FY93Lw4p4B2e0ms6v4/HYEHEEm9SBofOIeCcRPhlXQsvWWyuG+Xmp+wgG6UcLMNUpjBUmQ9JzzslYdV5U1Z5DNWAT108PHUuHzRhj6/XDDAMcqijbHMXMiM4JxH9Uq2tDf9Lty0Co9wu4SHhqYKoDgElXnZkLgIw7pP7I5jfbMOzM24aflaGRT4ZwjZigVVIA0hURZuaL2DdZxBS94Qtpsx10qtofj411FFDcVgBvwQrr+lc3qWlkxiiBRGX+Gk4fst5neCcRDdcdLulOxzj0x1Id0QlEc2wspNhVWUPdYT3XBIxnT/VKo6om+EScAIkncsffbblm1/TMcEghzr2meMtswXnJKpBsbhMJ8V3HVmGOKpEqfsGFQd0voB1n0E80yuWeAxNQi9Tmt+ynebphJXHqNrNIMMlGCsZLr+qcnYgn/5wEsOxIII6nGj/3jIjOKeRLVIel/CQxWTGogr4jQmLw4vPawl94dT/QIvXU+YdGXr7OCJOkKjxRex4Tl6ItWuQNbSwAa4cBj6FqF98U5kHxYr7+mKXUoxIlTqcEHNliAE+NO43HfijYOl5FZHQNrnhLqgiEKy3NQ/evFZoZ/c4HV7h6SKzkqjHdHtKWy6JAXbOxOwKkYabQLO5DcOzo8TE5o5o+wgRdtrJzjMxt0KMcE86RbRoa1yxgwgW1tuaEUYGbsZFNAOTuQ0r+BRWetySlkEKcOEN1qRkpJqTea00RP0SspdyGNH0EY6YKUiDmg4opsypEKuZNKmIBu2NK3YogoF1X8Gr6cstAyfjg8VilHhhzhWnLAK1z3hNBeLvgOU10vo9YNOFyiMnrybOggjqyO7kWWYLzkl0o0V4JDwS3hLeKoeWl1gL3C18hGspCC3nTVklMqYGrKWbx4RILlTe2vJcHooXGOQQ78o1BJ3jXOCcRrZJd5uUt0t4SHiqIKrLVY1IFmMrHFNJ52B/YHGDRFVuPiNatHv5yimFdZ9B4NsTMotqC5pZUDTbqZ77anG0uhjLg/L6s3P5uOxOAn0WRFzi96ZDyStwTiPcJbule1i6B9I9opIYvVgIc1wl3QNKYkznT7UKpBWyK+BeOpg/TOxLF9N3AAxyqOPZSuQyV3BOIztCJMrHJTwkPCW8VBSdByXR+sRsiRSFJNH3R26ISGj38tVDKaz7DALfnrDFCqmWPUHRbKsafqtArIAjEcpvOpc/uxwnoT4LIohflEA/5RU4p5Gd0r0s3QupXhmAq4ThguOLj13Bqf+RFq+nnqMtsYdJoEeNmSrm1r8m2C3ILnMDXNGYuUdzcnM70EFKg/+UqjdLxZLN5olMQj5gofvB33Sg54G1hWChbXLDKxdV0np78jhfetpi0BKznaVJeaRFpW0XhLBzJqYqBGOrVZmXGaclcD2b2LwRXR9Bw+YbZOfNiz3yB1EYzyKiQ2vjih1EcLDe1owaM/AybgHoxZN5lUh2Dc1zQVgpwIU5BpdYDWg4VX+eBqOlj6DvDcRIBxRT5vY8bFHzjGmIlnEcV2rhUgi9feGptDpjNIS633gKozR35Ct8HEjA1A6v91E/kc6b6C2DTGZ83fTkZb2y5lnrCB8FCJCMfXmytFO3JyMmzRGTJ9IfIV25qpobquil/7suxP9ZMbDnFeDIAJfDE66WLnvpH15iMeFv9BrNAtAkoyc0a4CJswZhoqShGYrJgOfwgOj/GxMpuCx9NNEcSsz/kdaLiW5hvLIZlrbp/XQEFyx/xD+HgzYA3Met1gEWXftAWwOY5KAcEEkApJPAS1fYvHIVmRijujFI9n7fp0zdN2H+J3Nns1Hb/8eBY0+8UIaMb7u9mjmW0BQuMbKxo7Dv3mFey/U5S91YOZi7gBkcWU0i1XgBR4tFNXqASKEIignylw9XptPgHZ0hcDN2GiU4wLhEIx4hq1IVFBPkMHA1KuDtausjTTfPIXcGGyfRcEzyD19gsMi3oJkgj8H7CGGrmHHQjImvfkOloRBAcSxesw4UpFSu1EoD3S2LM3JQ7Yn2Lo2RSKCZII9B1ydNdw4ENdHsNVhVoqA4Fq8/ed4wqtWFn7rByfCC4XKyffI/b0EpP4vxTSezrt4XRcORAF8yHbEty4GXJk80io21rBy1huIYb3KZyynmiqiUqTvhaa/0SD5xTzNP5gJQTJDDwCW1cOR0xh6udRjsDnP6JFOCzjwkLpdZurJWJQqKY+medh2dZ3WUvlXpxrDXm/65Je45RT14DBQT5DBwZR1v/TiOYzOZjuj+SmBvgeUa+gKDRb5BcwyzjM44cSabv/KdftXXSdJw5XiU4nICksNxOZcST8VUlhxXOCcud0/gfr1CAMWxvVzXI9x0uq67xuv1MamdJyVO3NMGF1sTKCbIYeDa4trgjAq1ZZyVO5uV4EbaROPYfVCSguJYul1P0W2d1fFhBtWdOmCcB14l7thZUa0JFAu8cxgcVT1Vs3yj2JR1t4urFe4GlWjlfSclJ9aC5ljKZ3kzPEK5QqrIuqpikLg6HbR17U9MO/OFjzYcbMVXVsar9w776tGVkZAUBOewXPnBCNf7yP+ppLr04vfye01aLNyt+aqGUAzbbcilebFX+NQy7E0W8Xb6E/E9QJGDazu3/x6ehVrMfFL5ROCNHiQuLSKFgKJYE8pRzliYKUSBJxaNFhbaCRmACEQCippGNrCMKcre5SaJUXrcBiEAufq032jaz3/VWrayzjRLnGcRbkV98nKiswhbFIqsI6UHoWhhongWequQSrFSg24pIndTKNK8HCfLUwuapgrlA5F85TiifV78GkTylWNPLjR3sXy3cgzJMMUTksbLU0cTls2mvI66yeuTVsRxCTKoyJlo3jmzT/jt5680RcMFD8K3gBWpQhINggCrT+mKBPb9qm75lWMymNWX8le7c5Wj19lvEqQKtj3ovlDn1/y84bdQN17ZaHaynFf+yv6497sXnu8AqBmYEtuPhIPjD9O6vE0MwV6ttS0B2jCpnit47sccWR5aTITiV5Yz0TnBX/I6yzJb447Ufuqt8CpMa25Ax1rcD+roKl/pY0qv7NgIXpG/B3tm+LZSt2K9ZNblIiYQKD7Ixbltt/xibaioWkiQupgJ7PgUYeu2xt8xGZ+VboGXXPGlIkMVKmxYnKg8B6773oUq5buhwnrNBFLWj+GIUNefraOFOYsuNFY3Y3/7+auZzkW0BnsIgwwnsssFYxtbgWnY3coUenLXHxEWBxbK2z1td96rdUd3ilvtwfHpaqyjQujvWolm9ugNA8MqNje8UfaMj9cqgA/YUsZ94iIiZNan7I32s5wgb58lsrLLxSlmjfP9+afZeF8Kxvty6KYwDUhu7aqVXSOmMrMaTJ3IeKnMkcbHnxmSSzod6pYBTJnolL8++x8/JqOUcuq6P95/n7Ve+9THLjFifEKmJCWVzVsYYdBJRRkRlC49mRbQoUBp8SX7D0J5qbPzIs2cpvFuKdIlfo9byMWlS8+LlGMaiLulA4fcO6i6JN6WyjafU1mlAbWUy5JI5y1ETNoqSyQspWnSC2kWLD2uhL9JmiMFrsS3+V7iGG1gJXV1S9Gqhivap0oYKr1gPr5GRFNQaTAl9sxbyDGkupTcEekqi/JBA0cpCyVhDCJDaQmRZFBqweQ0Tw7t5WwePYJ3y0m7HKjjff9LMXbyv6tOTs+h1C77fTE4/J9/L9AGlnAYSziCJRzDEo5jifUAL3wbEE6xlEsoOQgeAgfFOQ6CRwovt34vMo8BU9eIMxwU1/Bu6+8i8yRg4hpxjYPgqcGrrZ+LzDOBaWvEOQ6C5wxvtv4tMi8AN7aOrQvXsGWJFAHLGgvFJfzXerTqPAqWa21ZF14U5htDroDiVUDEJVC8AURcw2WtE6vOe8BvY8g1UHwYjNWar+p8Ciw2hpwDxZfCS63fqs43w1VjyCmIuIJ9WosVXUfICiPVkAfgmNZVVeeF4Z0x5AxEXAPFq4KIK6B4E6B4Z5ikNdKocwm71JAPBhHn8EXrnarDII4OyQwHFWY4GK3Q2CUvhoNqisxwUGGGg9H9jEPyoiNihw/GkCugeAQMz5qi6rw4rC+GXAPFq4GIK6B4UxBxCaoQHC98C0B+NvOIPLTDb83aHKv9hmiXrATc/x0TAOTBAZIQQU5As+Em9CSm8/3voGm4xW2fav7Q3t3R/H6pxLcvZgCSyqCf+63/OheK0WzzgJBGpLIiKNbJNt0zz3NUNBNeo7RbgmK9ssWH+qW6/o6ifbetwFNG80P0+ppCk4QKu7pLMQSh5Jn98uG/wC/58zPbm8gXFqHv3XG16WunyxJZKpci0we1nSEDRmXL+T4IhbzAfTeg12s66nWkT9G4bjX7pLFHh1QAZUVXfrZ0SXdq8Xhca3cjNQNo93ejP0dde6pBazEcz/ijIq6OBas4c/3QYZhxTpN+aResjrSa0yGjcnkFDb3p78cSzlKOUq8pxjWjLqWUxfe2hZPUH0nN3dtEY8RLlFjSDpnNkJPUPJBAptFsYTTRqHWVhJoF37jajA1lUGCMEVeTtRhr5MqL7KooQBrq6AG8L6UHrXxqocPbLS92l9JbhiZXPFu/LQ8OPeDS3qwhduWvsX8MGZYMg8uEF0d0GuBGZpWu5kJnTqgJHuJ5Di8LuyPlcij+xrWmpSjMrP6JDPdAwD78QBPRH17+vExIkc+GNYqsPGwa1GztGnovVsfmo8uHr/akZVD4AA=="></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_minimum-path-sum"></div></div>
</details><hr /><br />

</div>

</details>
</div>

