<p>给定一种规律 <code>pattern</code>&nbsp;和一个字符串&nbsp;<code>s</code>&nbsp;，判断 <code>s</code>&nbsp;是否遵循相同的规律。</p>

<p>这里的&nbsp;<strong>遵循&nbsp;</strong>指完全匹配，例如，&nbsp;<code>pattern</code>&nbsp;里的每个字母和字符串&nbsp;<code>s</code><strong>&nbsp;</strong>中的每个非空单词之间存在着双向连接的对应规律。</p>

<p>&nbsp;</p>

<p><strong class="example">示例1:</strong></p>

<pre>
<strong>输入:</strong> pattern = <span><code>"abba"</code></span>, s = <span><code>"dog cat cat dog"</code></span>
<strong>输出:</strong> true</pre>

<p><strong class="example">示例 2:</strong></p>

<pre>
<strong>输入:</strong>pattern = <span><code>"abba"</code></span>, s = <span><code>"dog cat cat fish"</code></span>
<strong>输出:</strong> false</pre>

<p><strong class="example">示例 3:</strong></p>

<pre>
<strong>输入:</strong> pattern = <span><code>"aaaa"</code></span>, s = <span><code>"dog cat cat dog"</code></span>
<strong>输出:</strong> false</pre>

<p>&nbsp;</p>

<p><strong>提示:</strong></p>

<ul> 
 <li><code>1 &lt;= pattern.length &lt;= 300</code></li> 
 <li><code>pattern</code>&nbsp;只包含小写英文字母</li> 
 <li><code>1 &lt;= s.length &lt;= 3000</code></li> 
 <li><code>s</code>&nbsp;只包含小写英文字母和&nbsp;<code>' '</code></li> 
 <li><code>s</code>&nbsp;<strong>不包含</strong> 任何前导或尾随对空格</li> 
 <li><code>s</code>&nbsp;中每个单词都被 <strong>单个空格 </strong>分隔</li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>哈希表 | 字符串</details><br>

<div>👍 669, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：已完成网站教程、网站习题、配套插件中所有多语言代码的校准，解决了之前 chatGPT 翻译可能出错的问题~**

<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

原谅我一开始都没理解这题啥意思，原来就是类似我们小学学的叠词，比方说 AABB -> 大大方方，ABAB -> 打听打听。题目其实就是问你 `s` 是否符合 `pattern` 的叠词模式。

那思路就很简单了，利用哈希表，把 `pattern` 中的每个叠词模式字符在 `s` 中的对应单词记录下来，就能判断 `s` 是否匹配 `pattern` 的模式了，比较简单。

另外，这道题的进阶题目 [291. 单词规律 II](/problems/word-pattern-ii) 比较有意思，考察暴力穷举算法。

</div>

**标签：哈希表**

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        size_t start = 0;
        size_t end = s.find(' ');
        while (end != string::npos) {
            words.push_back(s.substr(start, end - start));
            start = end + 1;
            end = s.find(' ', start);
        }
        words.push_back(s.substr(start));
        
        if (pattern.length() != words.size()) {
            return false;
        }
        
        // 记录 pattern 字符到单词的映射
        unordered_map<char, string> patternToWord;
        // 记录那些已经有 pattern 对应的单词
        unordered_set<string> wordSet;
        
        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern[i];
            string word = words[i];
            if (patternToWord.find(c) == patternToWord.end()) {
                if (wordSet.find(word) != wordSet.end()) {
                    // 这个单词以前已经有其他模式字符对应了
                    return false;
                }
                // 添加 c -> word 的映射
                patternToWord[c] = word;
            } else {
                // 这个 pattern 字符已经出现过，确保和之前对应的单词相同
                if (patternToWord[c] != word) {
                    return false;
                }
            }
            // 这个单词已经有模式字符对应
            wordSet.insert(word);
        }
        return true;
    }
};

class Solution2 {
public:
    bool wordPattern(string pattern, string s) {
        vector<string> words;
        size_t start = 0;
        size_t end = s.find(' ');
        while (end != string::npos) {
            words.push_back(s.substr(start, end - start));
            start = end + 1;
            end = s.find(' ', start);
        }
        words.push_back(s.substr(start));
        
        if (pattern.length() != words.size()) {
            return false;
        }
        
        // 记录 pattern 字符到单词的映射
        unordered_map<string, char> wordToPattern;
        // 记录那些已经有 pattern 对应的单词
        unordered_set<char> patternCharSet;
        
        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern[i];
            string word = words[i];
            if (wordToPattern.find(word) == wordToPattern.end()) {
                // 当前这个单词还没有对应的模式字符
                if (patternCharSet.find(c) != patternCharSet.end()) {
                    // 对应的模式字符之前已经对应了其他单词
                    return false;
                }
                // 添加 word -> c 的映射
                wordToPattern[word] = c;
            } else {
                // 这个单词之前已经出现过，确保当前单词和之前对应的模式字符相同
                if (wordToPattern[word] != c) {
                    return false;
                }
            }
            patternCharSet.insert(c);
        }
        return true;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
# 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words):
            return False
        # 记录 pattern 字符到单词的映射
        pattern_to_word = {}
        # 记录那些已经有 pattern 对应的单词
        word_set = set()

        for i, c in enumerate(pattern):
            word = words[i]
            if c not in pattern_to_word:
                if word in word_set:
                    # 这个单词以前已经有其他模式字符对应了
                    return False
                # 添加 c -> word 的映射
                pattern_to_word[c] = word
            else:
                # 这个 pattern 字符已经出现过，确保和之前对应的单词相同
                if pattern_to_word[c] != word:
                    return False
            # 这个单词已经有模式字符对应
            word_set.add(word)
        return True


class Solution2:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words):
            return False
        # 记录 pattern 字符到单词的映射
        word_to_pattern = {}
        pattern_char_set = set()

        for i, c in enumerate(pattern):
            word = words[i]
            if word not in word_to_pattern:
                # 当前这个单词还没有对应的模式字符
                if c in pattern_char_set:
                    # 对应的模式字符之前已经对应了其他单词
                    return False
                # 添加 word -> c 的映射
                word_to_pattern[word] = c
            else:
                # 这个单词之前已经出现过，确保当前单词和之前对应的模式字符相同
                if word_to_pattern[word] != c:
                    return False
            pattern_char_set.add(c)
        return True
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if (pattern.length() != words.length) {
            return false;
        }
        // 记录 pattern 字符到单词的映射
        HashMap<Character, String> patternToWord = new HashMap<>();
        // 记录那些已经有 pattern 对应的单词
        HashSet<String> wordSet = new HashSet<>();

        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern.charAt(i);
            String word = words[i];
            if (!patternToWord.containsKey(c)) {
                if (wordSet.contains(word)) {
                    // 这个单词以前已经有其他模式字符对应了
                    return false;
                }
                // 添加 c -> word 的映射
                patternToWord.put(c, word);
            } else {
                // 这个 pattern 字符已经出现过，确保和之前对应的单词相同
                if (!patternToWord.get(c).equals(word)) {
                    return false;
                }
            }
            // 这个单词已经有模式字符对应
            wordSet.add(word);
        }
        return true;
    }
}



class Solution2 {
    public boolean wordPattern(String pattern, String s) {
        String[] words = s.split(" ");
        if (pattern.length() != words.length) {
            return false;
        }
        // 记录 pattern 字符到单词的映射
        HashMap<String, Character> wordToPattern = new HashMap<>();
        HashSet<Character> patternCharSet = new HashSet<>();

        for (int i = 0; i < pattern.length(); i++) {
            char c = pattern.charAt(i);
            String word = words[i];
            if (!wordToPattern.containsKey(word)) {
                // 当前这个单词还没有对应的模式字符
                if (patternCharSet.contains(c)) {
                    // 对应的模式字符之前已经对应了其他单词
                    return false;
                }
                // 添加 word -> c 的映射
                wordToPattern.put(word, c);
            } else {
                // 这个单词之前已经出现过，确保当前单词和之前对应的模式字符相同
                if (!wordToPattern.get(word).equals(c)) {
                    return false;
                }
            }
            patternCharSet.add(c);
        }
        return true;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

func wordPattern(pattern string, s string) bool {
    words := strings.Split(s, " ")
    if len(pattern) != len(words) {
        return false
    }
    // 记录 pattern 字符到单词的映射
    patternToWord := make(map[rune]string)
    // 记录那些已经有 pattern 对应的单词
    wordSet := make(map[string]bool)

    for i, c := range pattern {
        word := words[i]
        if _, ok := patternToWord[c]; !ok {
            if wordSet[word] {
                // 这个单词以前已经有其他模式字符对应了
                return false
            }
            // 添加 c -> word 的映射
            patternToWord[c] = word
        } else {
            // 这个 pattern 字符已经出现过，确保和之前对应的单词相同
            if patternToWord[c] != word {
                return false
            }
        }
        // 这个单词已经有模式字符对应
        wordSet[word] = true
    }
    return true
}

func wordPattern2(pattern string, s string) bool {
    words := strings.Split(s, " ")
    if len(pattern) != len(words) {
        return false
    }
    // 记录 pattern 字符到单词的映射
    wordToPattern := make(map[string]rune)
    patternCharSet := make(map[rune]bool)

    for i, c := range pattern {
        word := words[i]
        if _, ok := wordToPattern[word]; !ok {
            // 当前这个单词还没有对应的模式字符
            if patternCharSet[c] {
                // 对应的模式字符之前已经对应了其他单词
                return false
            }
            // 添加 word -> c 的映射
            wordToPattern[word] = c
        } else {
            // 这个单词之前已经出现过，确保当前单词和之前对应的模式字符相同
            if wordToPattern[word] != c {
                return false
            }
        }
        patternCharSet[c] = true
    }
    return true
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

var wordPattern = function(pattern, s) {
    const words = s.split(" ");
    if (pattern.length !== words.length) {
        return false;
    }
    // 记录 pattern 字符到单词的映射
    const patternToWord = new Map();
    // 记录那些已经有 pattern 对应的单词
    const wordSet = new Set();

    for (let i = 0; i < pattern.length; i++) {
        const c = pattern[i];
        const word = words[i];
        if (!patternToWord.has(c)) {
            if (wordSet.has(word)) {
                // 这个单词以前已经有其他模式字符对应了
                return false;
            }
            // 添加 c -> word 的映射
            patternToWord.set(c, word);
        } else {
            // 这个 pattern 字符已经出现过，确保和之前对应的单词相同
            if (patternToWord.get(c) !== word) {
                return false;
            }
        }
        // 这个单词已经有模式字符对应
        wordSet.add(word);
    }
    return true;
};

var wordPattern2 = function(pattern, s) {
    const words = s.split(" ");
    if (pattern.length !== words.length) {
        return false;
    }
    // 记录 pattern 字符到单词的映射
    const wordToPattern = new Map();
    // 记录那些已经有模式字符对应的单词
    const patternCharSet = new Set();

    for (let i = 0; i < pattern.length; i++) {
        const c = pattern[i];
        const word = words[i];
        if (!wordToPattern.has(word)) {
            // 当前这个单词还没有对应的模式字符
            if (patternCharSet.has(c)) {
                // 对应的模式字符之前已经对应了其他单词
                return false;
            }
            // 添加 word -> c 的映射
            wordToPattern.set(word, c);
        } else {
            // 这个单词之前已经出现过，确保当前单词和之前对应的模式字符相同
            if (wordToPattern.get(word) !== c) {
                return false;
            }
        }
        patternCharSet.add(c);
    }
    return true;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🍭🍭 算法可视化 🍭🍭</strong></summary><div id="data_word-pattern" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_word-pattern"></div></div>
</details><hr /><br />

</div>

</details>
</div>

