<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>

<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>

<p>&nbsp;</p>

<p><strong>示例&nbsp;1：</strong></p>

<pre>
<strong>输入：</strong>nums = [2,3,2]
<strong>输出：</strong>3
<strong>解释：</strong>你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3,1]
<strong>输出：</strong>4
<strong>解释：</strong>你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
&nbsp;    偷窃到的最高金额 = 1 + 3 = 4 。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>3
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= nums.length &lt;= 100</code></li> 
 <li><code>0 &lt;= nums[i] &lt;= 1000</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数组 | 动态规划</details><br>

<div>👍 1630, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：网站新增大量习题，新增排序算法专题及可视化，具体请查看 [网站更新日志](https://labuladong.online/algo/changelog/website/)~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=house-robber-ii" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。

![](https://labuladong.online/algo/images/robber/3.jpg)

这三种情况哪个结果最大，就是最终答案。其实，情况一的结果肯定最小，我们只要比较情况二和情况三就行了，**因为这两种情况对于房子的选择余地比情况一大，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小**。

把 [打家劫舍 I](#house-robber) 的解法稍加改造即可。

- **详细题解**：
  - [一个方法团灭 LeetCode 打家劫舍问题](https://labuladong.online/algo/dynamic-programming/house-robber/)

</div>

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

#include <vector>
#include <algorithm>
using namespace std;

class Solution {

public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];

        vector<int> memo1(n, -1);
        vector<int> memo2(n, -1);
        // 两次调用使用两个不同的备忘录
        return max(
            dp(nums, 0, n - 2, memo1),
            dp(nums, 1, n - 1, memo2)
        );
    }

    // 定义：计算闭区间 [start,end] 的最优结果
    int dp(vector<int>& nums, int start, int end, vector<int>& memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // 状态转移方程
        int res = max(
            dp(nums, start + 2, end, memo) + nums[start],
            dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution:
    def rob(self, nums):
        n = len(nums)
        if n == 1:
            return nums[0]

        memo1 = [-1] * n
        memo2 = [-1] * n
        # 两次调用使用两个不同的备忘录
        return max(
            self.dp(nums, 0, n - 2, memo1),
            self.dp(nums, 1, n - 1, memo2)
        )

    # 定义：计算闭区间 [start,end] 的最优结果
    def dp(self, nums, start, end, memo):
        if start > end:
            return 0

        if memo[start] != -1:
            return memo[start]
        # 状态转移方程
        res = max(
            self.dp(nums, start + 2, end, memo) + nums[start],
            self.dp(nums, start + 1, end, memo)
        )

        memo[start] = res
        return res
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {

    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) return nums[0];

        int[] memo1 = new int[n];
        int[] memo2 = new int[n];
        Arrays.fill(memo1, -1);
        Arrays.fill(memo2, -1);
        // 两次调用使用两个不同的备忘录
        return Math.max(
                dp(nums, 0, n - 2, memo1),
                dp(nums, 1, n - 1, memo2)
        );
    }

    // 定义：计算闭区间 [start,end] 的最优结果
    int dp(int[] nums, int start, int end, int[] memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] != -1) {
            return memo[start];
        }
        // 状态转移方程
        int res = Math.max(
                dp(nums, start + 2, end, memo) + nums[start],
                dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

func rob(nums []int) int {
    n := len(nums)
    if n == 1 {
        return nums[0]
    }

    memo1 := make([]int, n)
    memo2 := make([]int, n)
    for i := range memo1 {
        memo1[i] = -1
        memo2[i] = -1
    }
    // 两次调用使用两个不同的备忘录
    return max(
        dp(nums, 0, n-2, memo1),
        dp(nums, 1, n-1, memo2),
    )
}

// 定义：计算闭区间 [start,end] 的最优结果
func dp(nums []int, start, end int, memo []int) int {
    if start > end {
        return 0
    }

    if memo[start] != -1 {
        return memo[start]
    }
    // 状态转移方程
    res := max(
        dp(nums, start+2, end, memo)+nums[start],
        dp(nums, start+1, end, memo),
    )

    memo[start] = res
    return res
}

func max(x, y int) int {
    if x > y {
        return x
    }
    return y
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

var rob = function(nums) {
    const n = nums.length;
    if (n === 1) return nums[0];

    const memo1 = new Array(n).fill(-1);
    const memo2 = new Array(n).fill(-1);
    // 两次调用使用两个不同的备忘录
    return Math.max(
        dp(nums, 0, n - 2, memo1),
        dp(nums, 1, n - 1, memo2)
    );

    // 定义：计算闭区间 [start,end] 的最优结果
    function dp(nums, start, end, memo) {
        if (start > end) {
            return 0;
        }

        if (memo[start] !== -1) {
            return memo[start];
        }
        // 状态转移方程
        const res = Math.max(
            dp(nums, start + 2, end, memo) + nums[start],
            dp(nums, start + 1, end, memo)
        );

        memo[start] = res;
        return res;
    }
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🥳🥳 算法可视化 🥳🥳</strong></summary><div id="data_house-robber-ii" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_house-robber-ii"></div></div>
</details><hr /><br />

</div>

</details>
</div>

