<p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p>

<p>只有当&nbsp;<code>c &lt;= a</code>&nbsp;且&nbsp;<code>b &lt;= d</code>&nbsp;时，我们才认为区间&nbsp;<code>[a,b)</code> 被区间&nbsp;<code>[c,d)</code> 覆盖。</p>

<p>在完成所有删除操作后，请你返回列表中剩余区间的数目。</p>

<p>&nbsp;</p>

<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>intervals = [[1,4],[3,6],[2,8]]
<strong>输出：</strong>2
<strong>解释：</strong>区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong>​​​​​​</p>

<ul> 
 <li><code>1 &lt;= intervals.length &lt;= 1000</code></li> 
 <li><code>0 &lt;= intervals[i][0] &lt;&nbsp;intervals[i][1] &lt;= 10^5</code></li> 
 <li>对于所有的&nbsp;<code>i != j</code>：<code>intervals[i] != intervals[j]</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数组 | 排序</details><br>

<div>👍 118, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：已完成网站教程、网站习题、配套插件中所有多语言代码的校准，解决了之前 chatGPT 翻译可能出错的问题~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=remove-covered-intervals" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

按照区间的起点进行升序排序：

![](https://labuladong.online/algo/images/mergeInterval/1.jpg)

排序之后，两个相邻区间可能有如下三种情况：

![](https://labuladong.online/algo/images/区间合集/1.jpeg)

对于情况一，找到了覆盖区间。

对于情况二，两个区间可以合并，成一个大区间。

对于情况三，两个区间完全不相交。

依据几种情况，就可以写出代码了。

**详细题解：[一个方法解决三道区间问题](https://labuladong.online/algo/practice-in-action/interval-problem-summary/)**

</div>

**标签：[区间问题](https://labuladong.online/algo/)，排序**

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，但可能缺失注释。必要时请对照我的 java 代码查看。

class Solution {
public:
    int removeCoveredIntervals(vector<vector<int>>& intervals) {
        // 按照起点升序排列，起点相同时降序排列
        sort(intervals.begin(), intervals.end(), [](vector<int>& a, vector<int>& b) {
            if (a[0] == b[0]) {
                return b[1] < a[1];
            }
            return a[0] < b[0];
        });

        // 记录合并区间的起点和终点
        int left = intervals[0][0];
        int right = intervals[0][1];

        int res = 0;
        for (int i = 1; i < intervals.size(); i++) {
            vector<int>& intv = intervals[i];
            // 情况一，找到覆盖区间
            if (left <= intv[0] && right >= intv[1]) {
                res++;
            }
            // 情况二，找到相交区间，合并
            if (right >= intv[0] && right <= intv[1]) {
                right = intv[1];
            }
            // 情况三，完全不相交，更新起点和终点
            if (right < intv[0]) {
                left = intv[0];
                right = intv[1];
            }
        }

        return intervals.size() - res;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，但可能缺失注释。必要时请对照我的 java 代码查看。

from typing import List

class Solution:
    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:
        # 按照起点升序排列，起点相同时降序排列
        intervals.sort(key=lambda x: (x[0], -x[1]))

        # 记录合并区间的起点和终点
        left = intervals[0][0]
        right = intervals[0][1]

        res = 0
        for intv in intervals[1:]:
            # 情况一，找到覆盖区间
            if left <= intv[0] and right >= intv[1]:
                res += 1
            # 情况二，找到相交区间，合并
            if right >= intv[0] and right <= intv[1]:
                right = intv[1]
            # 情况三，完全不相交，更新起点和终点
            if right < intv[0]:
                left = intv[0]
                right = intv[1]
        
        return len(intervals) - res
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public int removeCoveredIntervals(int[][] intervals) {
        // 按照起点升序排列，起点相同时降序排列
        Arrays.sort(intervals, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });

        // 记录合并区间的起点和终点
        int left = intervals[0][0];
        int right = intervals[0][1];

        int res = 0;
        for (int i = 1; i < intervals.length; i++) {
            int[] intv = intervals[i];
            // 情况一，找到覆盖区间
            if (left <= intv[0] && right >= intv[1]) {
                res++;
            }
            // 情况二，找到相交区间，合并
            if (right >= intv[0] && right <= intv[1]) {
                right = intv[1];
            }
            // 情况三，完全不相交，更新起点和终点
            if (right < intv[0]) {
                left = intv[0];
                right = intv[1];
            }
        }

        return intervals.length - res;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，但可能缺失注释。必要时请对照我的 java 代码查看。

import (
    "sort"
)

func removeCoveredIntervals(intervals [][]int) int {
    // 按照起点升序排列，起点相同时降序排列
    sort.Slice(intervals, func(i, j int) bool {
        if intervals[i][0] == intervals[j][0] {
            return intervals[i][1] > intervals[j][1]
        }
        return intervals[i][0] < intervals[j][0]
    })

    // 记录合并区间的起点和终点
    left := intervals[0][0]
    right := intervals[0][1]

    res := 0
    for i := 1; i < len(intervals); i++ {
        intv := intervals[i]
        // 情况一，找到覆盖区间
        if left <= intv[0] && right >= intv[1] {
            res++
        }
        // 情况二，找到相交区间，合并
        if right >= intv[0] && right <= intv[1] {
            right = intv[1]
        }
        // 情况三，完全不相交，更新起点和终点
        if right < intv[0] {
            left = intv[0]
            right = intv[1]
        }
    }

    return len(intervals) - res
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，但可能缺失注释。必要时请对照我的 java 代码查看。

var removeCoveredIntervals = function(intervals) {
    // 按照起点升序排列，起点相同时降序排列
    intervals.sort((a, b) => {
        if (a[0] === b[0]) {
            return b[1] - a[1];
        }
        return a[0] - b[0];
    });

    // 记录合并区间的起点和终点
    let left = intervals[0][0];
    let right = intervals[0][1];

    let res = 0;
    for (let i = 1; i < intervals.length; i++) {
        let intv = intervals[i];
        // 情况一，找到覆盖区间
        if (left <= intv[0] && right >= intv[1]) {
            res++;
        }
        // 情况二，找到相交区间，合并
        if (right >= intv[0] && right <= intv[1]) {
            right = intv[1];
        }
        // 情况三，完全不相交，更新起点和终点
        if (right < intv[0]) {
            left = intv[0];
            right = intv[1];
        }
    }

    return intervals.length - res;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🎃🎃 算法可视化 🎃🎃</strong></summary><div id="data_remove-covered-intervals" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_remove-covered-intervals"></div></div>
</details><hr /><br />

**类似题目**：
  - [56. 合并区间 🟠](/problems/merge-intervals)
  - [986. 区间列表的交集 🟠](/problems/interval-list-intersections)
  - [剑指 Offer II 074. 合并区间 🟠](/problems/SsGoHC)

</div>

</details>
</div>

