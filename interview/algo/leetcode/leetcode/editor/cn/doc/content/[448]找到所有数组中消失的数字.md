<p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [4,3,2,7,8,2,3,1]
<strong>输出：</strong>[5,6]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,1]
<strong>输出：</strong>[2]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>n == nums.length</code></li> 
 <li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li> 
 <li><code>1 &lt;= nums[i] &lt;= n</code></li> 
</ul>

<p><strong>进阶：</strong>你能在不使用额外空间且时间复杂度为<em> </em><code>O(n)</code><em> </em>的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。</p>

<details><summary><strong>Related Topics</strong></summary>数组 | 哈希表</details><br>

<div>👍 1338, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：网站新增大量习题，新增排序算法专题及可视化，具体请查看 [网站更新日志](https://labuladong.online/algo/changelog/website/)~**

<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

这道题的常规的解法很简单，用一个数组模拟哈希集合，很容易找到 `nums` 中那些没有出现的元素。

非要优化空间复杂度也简单，说白了就是用输入数组 `nums` 本身作为哈希集合。只要你做了 [442. 数组中重复的数据](/problems/find-all-duplicates-in-an-array)，不难想到这道题也有不用额外的存储空间的解法。

因为题目说 `nums` 中的元素取值都在 `[1, n]` 之间，所以在 `[0, n-1]` 之间，即元素本身就和索引可以形成一一映射关系，所以可以用 `nums` 本身模拟哈希集合的效果，可以参考这篇文章 [如何寻找缺失和重复的元素](https://labuladong.online/algo/frequency-interview/mismatch-set/)。

我们给 `nums` 中所有元素对应的索引做标记，那么最终缺失的那些元素对应的索引就不会被标记，我们也就可以把缺失的那些元素找出来。

> 注意：用乘 -1 的方式给索引做标记的前提是，`nums` 中的元素都为正数，不能包含 0，否则无法区分该索引是否被标记。

- **详细题解**：
  - [【强化练习】哈希表更多习题](https://labuladong.online/algo/problem-set/hash-table/)

</div>

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

#include <vector>

class Solution {
public:
    std::vector<int> findDisappearedNumbers(std::vector<int>& nums) {
        int n = nums.size();
        std::vector<int> count(n + 1, 0);
        for (int num : nums) {
            count[num]++;
        }
        std::vector<int> res;
        for (int num = 1; num <= n; num++) {
            if (count[num] == 0) {
                res.push_back(num);
            }
        }
        return res;
    }
};

class Solution2 {
public:
    std::vector<int> findDisappearedNumbers(std::vector<int>& nums) {
        for (int num : nums) {
            // 注意索引，nums 中元素大小从 1 开始，
            // 而索引是从 0 开始的，所以有一位索引偏移
            int index = abs(num) - 1;
            if (nums[index] > 0) {
                // 把索引 num - 1 置为负数
                nums[index] = -nums[index];
            } else {
                // 之前已经把对应索引的元素变成负数了，
                // 这说明 num 重复出现了两次，但我们什么都不用做，让索引继续保持负数
                // (No action needed here, so no code change, just keeping the comments.)
            }
        }

        std::vector<int> res;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] > 0) {
                // 说明没有元素和这个索引对应，即找到一个缺失元素
                res.push_back(i + 1);
            }
        }

        return res;
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        count = [0] * (n + 1)
        for num in nums:
            count[num] += 1
        res = []
        for num in range(1, n + 1):
            if count[num] == 0:
                res.append(num)
        return res


class Solution2:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for num in nums:
            # 注意索引，nums 中元素大小从 1 开始，
            # 而索引是从 0 开始的，所以有一位索引偏移
            if nums[abs(num) - 1] < 0:
                # 之前已经把对应索引的元素变成负数了，
                # 这说明 num 重复出现了两次，但我们什么都不用做，让索引继续保持负数
                pass
            else:
                # 把索引 num - 1 置为负数
                nums[abs(num) - 1] *= -1

        res = []
        for i in range(len(nums)):
            if nums[i] > 0:
                # 说明没有元素和这个索引对应，即找到一个缺失元素
                res.append(i + 1)
        return res
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        int n = nums.length;
        int[] count = new int[n + 1];
        for (int num : nums) {
            count[num]++;
        }
        List<Integer> res = new LinkedList<>();
        for (int num = 1; num <= n; num++) {
            if (count[num] == 0) {
                res.add(num);
            }
        }
        return res;
    }
}


class Solution2 {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for (int num : nums) {
            // 注意索引，nums 中元素大小从 1 开始，
            // 而索引是从 0 开始的，所以有一位索引偏移
            if (nums[Math.abs(num) - 1] < 0) {
                // 之前已经把对应索引的元素变成负数了，
                // 这说明 num 重复出现了两次，但我们什么都不用做，让索引继续保持负数
            } else {
                // 把索引 num - 1 置为负数
                nums[Math.abs(num) - 1] *= -1;
            }
        }

        List<Integer> res = new LinkedList<>();
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > 0) {
                // 说明没有元素和这个索引对应，即找到一个缺失元素
                res.add(i + 1);
            }
        }

        return res;
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

func findDisappearedNumbers(nums []int) []int {
    n := len(nums)
    count := make([]int, n+1)
    for _, num := range nums {
        count[num]++
    }
    res := []int{}
    for num := 1; num <= n; num++ {
        if count[num] == 0 {
            res = append(res, num)
        }
    }
    return res
}

func findDisappearedNumbers2(nums []int) []int {
    for _, num := range nums {
        // 注意索引，nums 中元素大小从 1 开始，
        // 而索引是从 0 开始的，所以有一位索引偏移
        if nums[abs(num)-1] < 0 {
            // 之前已经把对应索引的元素变成负数了，
            // 这说明 num 重复出现了两次，但我们什么都不用做，让索引继续保持负数
        } else {
            // 把索引 num - 1 置为负数
            nums[abs(num)-1] *= -1
        }
    }

    res := []int{}
    for i := 0; i < len(nums); i++ {
        if nums[i] > 0 {
            // 说明没有元素和这个索引对应，即找到一个缺失元素
            res = append(res, i+1)
        }
    }

    return res
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

var findDisappearedNumbers = function(nums) {
    let n = nums.length;
    let count = new Array(n + 1).fill(0);
    for (let num of nums) {
        count[num]++;
    }
    let res = [];
    for (let num = 1; num <= n; num++) {
        if (count[num] === 0) {
            res.push(num);
        }
    }
    return res;
};

var findDisappearedNumbers2 = function(nums) {
    for (let num of nums) {
        // 注意索引，nums 中元素大小从 1 开始，
        // 而索引是从 0 开始的，所以有一位索引偏移
        let index = Math.abs(num) - 1;
        if (nums[index] < 0) {
            // 之前已经把对应索引的元素变成负数了，
            // 这说明 num 重复出现了两次，但我们什么都不用做，让索引继续保持负数
        } else {
            // 把索引 num - 1 置为负数
            nums[index] *= -1;
        }
    }

    let res = [];
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            // 说明没有元素和这个索引对应，即找到一个缺失元素
            res.push(i + 1);
        }
    }

    return res;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🍭🍭 算法可视化 🍭🍭</strong></summary><div id="data_find-all-numbers-disappeared-in-an-array" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_find-all-numbers-disappeared-in-an-array"></div></div>
</details><hr /><br />

</div>

</details>
</div>

