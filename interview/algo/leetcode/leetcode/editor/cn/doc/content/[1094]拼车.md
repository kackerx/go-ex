<p>车上最初有&nbsp;<code>capacity</code>&nbsp;个空座位。车&nbsp;<strong>只能&nbsp;</strong>向一个方向行驶（也就是说，<strong>不允许掉头或改变方向</strong>）</p>

<p>给定整数&nbsp;<code>capacity</code>&nbsp;和一个数组 <code>trips</code> , &nbsp;<code>trip[i] = [numPassengers<sub>i</sub>, from<sub>i</sub>, to<sub>i</sub>]</code>&nbsp;表示第 <code>i</code> 次旅行有&nbsp;<code>numPassengers<sub>i</sub></code>&nbsp;乘客，接他们和放他们的位置分别是&nbsp;<code>from<sub>i</sub></code>&nbsp;和&nbsp;<code>to<sub>i</sub></code>&nbsp;。这些位置是从汽车的初始位置向东的公里数。</p>

<p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回&nbsp;<code>true</code>，否则请返回 <code>false</code>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 4
<strong>输出：</strong>false
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>trips = [[2,1,5],[3,3,7]], capacity = 5
<strong>输出：</strong>true
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= trips.length &lt;= 1000</code></li> 
 <li><code>trips[i].length == 3</code></li> 
 <li><code>1 &lt;= numPassengers<sub>i</sub>&nbsp;&lt;= 100</code></li> 
 <li><code>0 &lt;= from<sub>i</sub>&nbsp;&lt; to<sub>i</sub>&nbsp;&lt;= 1000</code></li> 
 <li><code>1 &lt;= capacity &lt;= 10<sup>5</sup></code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>数组 | 前缀和 | 排序 | 模拟 | 堆（优先队列）</details><br>

<div>👍 392, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：已完成网站教程、网站习题、配套插件中所有多语言代码的校准，解决了之前 chatGPT 翻译可能出错的问题~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=car-pooling" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

相信你已经能够联想到差分数组技巧了：**`trips[i]` 代表着一组区间操作，旅客的上车和下车就相当于数组的区间加减；只要结果数组中的元素都小于 `capacity`，就说明可以不超载运输所有旅客**。

这题还有一个细节，一批乘客从站点 `trip[1]` 上车，到站点 `trip[2]` 下车，呆在车上的站点应该是 `[trip[1], trip[2] - 1]`，这是需要被操作的索引区间。

**详细题解：[小而美的算法技巧：差分数组](https://labuladong.online/algo/data-structure/diff-array/)**

</div>

**标签：差分数组**

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        // 最多有 1000 个车站
        vector<int> nums(1001, 0);
        // 构造差分解法
        Difference df(nums);

        for (const auto& trip : trips) {
            // 乘客数量
            int val = trip[0];
            // 第 trip[1] 站乘客上车
            int i = trip[1];
            // 第 trip[2] 站乘客已经下车，
            // 即乘客在车上的区间是 [trip[1], trip[2] - 1]
            int j = trip[2] - 1;
            // 进行区间操作
            df.increment(i, j, val);
        }

        vector<int> res = df.result();

        // 客车自始至终都不应该超载
        for (int i = 0; i < res.size(); i++) {
            if (capacity < res[i]) {
                return false;
            }
        }
        return true;
    }

    // 差分数组工具类
    class Difference {
    private:
        // 差分数组
        vector<int> diff;

    public:
        // 输入一个初始数组，区间操作将在这个数组上进行
        Difference(vector<int>& nums) {
            assert(!nums.empty());
            diff.resize(nums.size());
            // 根据初始数组构造差分数组
            diff[0] = nums[0];
            for (int i = 1; i < nums.size(); i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        // 给闭区间 [i, j] 增加 val（可以是负数）
        void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.size()) {
                diff[j + 1] -= val;
            }
        }

        // 返回结果数组
        vector<int> result() {
            vector<int> res(diff.size());
            // 根据差分数组构造结果数组
            res[0] = diff[0];
            for (int i = 1; i < diff.size(); i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    };
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
# 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        # 最多有 1000 个车站
        nums = [0] * 1001
        # 构造差分解法
        df = self.Difference(nums)

        for trip in trips:
            # 乘客数量
            val = trip[0]
            # 第 trip[1] 站乘客上车
            i = trip[1]
            # 第 trip[2] 站乘客已经下车，
            # 即乘客在车上的区间是 [trip[1], trip[2] - 1]
            j = trip[2] - 1
            # 进行区间操作
            df.increment(i, j, val)

        res = df.result()

        # 客车自始至终都不应该超载
        for i in range(len(res)):
            if capacity < res[i]:
                return False
        return True

    # 差分数组工具类
    class Difference:
        # 差分数组
        def __init__(self, nums: List[int]):
            # 输入一个初始数组，区间操作将在这个数组上进行
            # 根据初始数组构造差分数组
            self.diff = [nums[0]] + [nums[i] - nums[i - 1] for i in range(1, len(nums))]

        # 给闭区间 [i, j] 增加 val（可以是负数）
        def increment(self, i: int, j: int, val: int) -> None:
            self.diff[i] += val
            if j + 1 < len(self.diff):
                self.diff[j + 1] -= val

        # 返回结果数组
        def result(self) -> List[int]:
            res = [self.diff[0]]
            # 根据差分数组构造结果数组
            for i in range(1, len(self.diff)):
                res.append(res[i - 1] + self.diff[i])
            return res
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        // 最多有 1000 个车站
        int[] nums = new int[1001];
        // 构造差分解法
        Difference df = new Difference(nums);

        for (int[] trip : trips) {
            // 乘客数量
            int val = trip[0];
            // 第 trip[1] 站乘客上车
            int i = trip[1];
            // 第 trip[2] 站乘客已经下车，
            // 即乘客在车上的区间是 [trip[1], trip[2] - 1]
            int j = trip[2] - 1;
            // 进行区间操作
            df.increment(i, j, val);
        }

        int[] res = df.result();

        // 客车自始至终都不应该超载
        for (int i = 0; i < res.length; i++) {
            if (capacity < res[i]) {
                return false;
            }
        }
        return true;
    }

    // 差分数组工具类
    class Difference {
        // 差分数组
        private int[] diff;

        // 输入一个初始数组，区间操作将在这个数组上进行
        public Difference(int[] nums) {
            assert nums.length > 0;
            diff = new int[nums.length];
            // 根据初始数组构造差分数组
            diff[0] = nums[0];
            for (int i = 1; i < nums.length; i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }

        // 给闭区间 [i, j] 增加 val（可以是负数）
        public void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }

        // 返回结果数组
        public int[] result() {
            int[] res = new int[diff.length];
            // 根据差分数组构造结果数组
            res[0] = diff[0];
            for (int i = 1; i < diff.length; i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    }

}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

func carPooling(trips [][]int, capacity int) bool {
    // 最多有 1000 个车站
    nums := make([]int, 1001)
    // 构造差分解法
    df := NewDifference(nums)

    for _, trip := range trips {
        // 乘客数量
        val := trip[0]
        // 第 trip[1] 站乘客上车
        i := trip[1]
        // 第 trip[2] 站乘客已经下车，
        // 即乘客在车上的区间是 [trip[1], trip[2] - 1]
        j := trip[2] - 1
        // 进行区间操作
        df.Increment(i, j, val)
    }

    res := df.Result()

    // 客车自始至终都不应该超载
    for _, v := range res {
        if capacity < v {
            return false
        }
    }
    return true
}

// 差分数组工具类
type Difference struct {
    diff []int // 差分数组
}

// 输入一个初始数组，区间操作将在这个数组上进行
func NewDifference(nums []int) *Difference {
    // 根据初始数组构造差分数组
    diff := make([]int, len(nums))
    diff[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        diff[i] = nums[i] - nums[i-1]
    }
    return &Difference{diff: diff}
}

// 给闭区间 [i, j] 增加 val（可以是负数）
func (d *Difference) Increment(i, j, val int) {
    d.diff[i] += val
    if j+1 < len(d.diff) {
        d.diff[j+1] -= val
    }
}

// 返回结果数组
func (d *Difference) Result() []int {
    // 根据差分数组构造结果数组
    res := make([]int, len(d.diff))
    res[0] = d.diff[0]
    for i := 1; i < len(d.diff); i++ {
        res[i] = res[i-1] + d.diff[i]
    }
    return res
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

var carPooling = function(trips, capacity) {
    // 最多有 1000 个车站
    const nums = new Array(1001).fill(0);
    // 构造差分解法
    const df = new Difference(nums);

    for (const trip of trips) {
        // 乘客数量
        const val = trip[0];
        // 第 trip[1] 站乘客上车
        const i = trip[1];
        // 第 trip[2] 站乘客已经下车，
        // 即乘客在车上的区间是 [trip[1], trip[2] - 1]
        const j = trip[2] - 1;
        // 进行区间操作
        df.increment(i, j, val);
    }

    const res = df.result();

    // 客车自始至终都不应该超载
    for (let i = 0; i < res.length; i++) {
        if (capacity < res[i]) {
            return false;
        }
    }
    return true;
};

// 差分数组工具类
class Difference {
    // 输入一个初始数组，区间操作将在这个数组上进行
    // 根据初始数组构造差分数组
    constructor(nums) {
        // 差分数组
        this.diff = [...nums];
        this.diff[0] = nums[0];
        for (let i = 1; i < nums.length; i++) {
            this.diff[i] = nums[i] - nums[i - 1];
        }
    }

    // 给闭区间 [i, j] 增加 val（可以是负数）
    increment(i, j, val) {
        this.diff[i] += val;
        if (j + 1 < this.diff.length) {
            this.diff[j + 1] -= val;
        }
    }

    // 返回结果数组
    result() {
        const res = new Array(this.diff.length);
        // 根据差分数组构造结果数组
        res[0] = this.diff[0];
        for (let i = 1; i < this.diff.length; i++) {
            res[i] = res[i - 1] + this.diff[i];
        }
        return res;
    }
}
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🌈🌈 算法可视化 🌈🌈</strong></summary><div id="data_car-pooling" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_car-pooling"></div></div>
</details><hr /><br />

**类似题目**：
  - [1109. 航班预订统计 🟠](/problems/corporate-flight-bookings)
  - [370. 区间加法 🟠](/problems/range-addition)

</div>

</details>
</div>

