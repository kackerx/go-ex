<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>

<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 4, k = 2
<strong>输出：</strong>
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1, k = 1
<strong>输出：</strong>[[1]]</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= n &lt;= 20</code></li> 
 <li><code>1 &lt;= k &lt;= n</code></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>回溯</details><br>

<div>👍 1665, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：已完成网站教程、网站习题、配套插件中所有多语言代码的校准，解决了之前 chatGPT 翻译可能出错的问题~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=combinations" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

> 本文有视频版：[回溯算法秒杀所有排列/组合/子集问题](https://www.bilibili.com/video/BV1Yt4y1t7dK)

这也是典型的回溯算法，`k` 限制了树的高度，`n` 限制了树的宽度，继续套我们以前讲过的 [回溯算法模板框架](https://labuladong.online/algo/essential-technique/backtrack-framework/) 就行了：

![](https://labuladong.online/algo/images/子集/2.jpg)

**详细题解：[回溯算法秒杀所有排列/组合/子集问题](https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/)**

</div>

**标签：[回溯算法](https://labuladong.online/algo/)，[数学](https://labuladong.online/algo/)**

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">cpp🟢</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">java🤖</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item active" data-tab-group="default"><div class="highlight">

```cpp
class Solution {
    public:

    vector<vector<int>> res;
    vector<vector<int>> combine(int n, int k) {
        if (k <= 0 || n <= 0) return res;
        vector<int> track;
        backtrack(n, k, 1, track);
        return res;
    }

    void backtrack(int n, int k, int start, vector<int>& track) {
        // 到达树的底部
        if (k == track.size()) {
            res.push_back(track);
            return;
        }
        // 注意 i 从 start 开始递增
        for (int i = start; i <= n; i++) {
            // 做选择
            track.push_back(i);
            backtrack(n, k, i + 1, track);
            // 撤销选择
            track.pop_back();
        }
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
# 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        def backtrack(start: int, track: List[int]):
            # 到达树的底部
            if len(track) == k:
                res.append(track[:])
                return
            # 注意 i 从 start 开始递增
            for i in range(start, n + 1):
                # 做选择
                track.append(i)
                backtrack(i + 1, track)
                # 撤销选择
                track.pop()
        backtrack(1, [])
        return res
```

</div></div>

<div data-tab-item="java" class="tab-item " data-tab-group="default"><div class="highlight">

```java
// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution {

    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        if (k <= 0 || n <= 0) return res;
        backtrack(n, k, 1, new ArrayList<>());
        return res;
    }

    private void backtrack(int n, int k, int start, List<Integer> track) {
        // 到达树的底部
        if (k == track.size()) {
            res.add(new ArrayList<>(track));
            return;
        }
        // 注意 i 从 start 开始递增
        for (int i = start; i <= n; i++) {
            // 做选择
            track.add(i);
            backtrack(n, k, i + 1, track);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

func combine(n int, k int) [][]int {
    var res [][]int
    if k <= 0 || n <= 0 {
        return res
    }
    var track []int
    backtrack(n, k, 1, &track, &res)
    return res
}

func backtrack(n int, k int, start int, track *[]int, res *[][]int) {
    // 到达树的底部
    if k == len(*track) {
        temp := make([]int, len(*track))
        copy(temp, *track)
        *res = append(*res, temp)
        return
    }
    // 注意 i 从 start 开始递增
    for i := start; i <= n; i++ {
        // 做选择
        *track = append(*track, i)
        backtrack(n, k, i+1, track, res)
        // 撤销选择
        *track = (*track)[:len(*track)-1]
    }
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

var combine = function(n, k) {
    let res = [];
    
    // @visualize status(track)
    var backtrack = function(n, k, start, track) {
        // 到达树的底部
        if (k === track.length) {
            res.push([...track]);
            return;
        }
        // 注意 i 从 start 开始递增
        for (let i = start; i <= n; i++) {
            // 做选择
            // @visualize choose(i)
            track.push(i);
            backtrack(n, k, i + 1, track);
            // 撤销选择
            // @visualize unchoose()
            track.pop();
        }
    }
    
    if (k <= 0 || n <= 0) return res;
    let track = [];
    backtrack(n, k, 1, track);
    return res;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🥳🥳 算法可视化 🥳🥳</strong></summary><div id="data_combinations" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_combinations"></div></div>
</details><hr /><br />

**类似题目**：
  - [216. 组合总和 III 🟠](/problems/combination-sum-iii)
  - [39. 组合总和 🟠](/problems/combination-sum)
  - [40. 组合总和 II 🟠](/problems/combination-sum-ii)
  - [46. 全排列 🟠](/problems/permutations)
  - [47. 全排列 II 🟠](/problems/permutations-ii)
  - [78. 子集 🟠](/problems/subsets)
  - [90. 子集 II 🟠](/problems/subsets-ii)
  - [剑指 Offer II 079. 所有子集 🟠](/problems/TVdhkn)
  - [剑指 Offer II 080. 含有 k 个元素的组合 🟠](/problems/uUsW3B)
  - [剑指 Offer II 081. 允许重复选择元素的组合 🟠](/problems/Ygoe9J)
  - [剑指 Offer II 082. 含有重复元素集合的组合 🟠](/problems/4sjJUc)
  - [剑指 Offer II 083. 没有重复元素集合的全排列 🟠](/problems/VvJkup)
  - [剑指 Offer II 084. 含有重复元素集合的全排列 🟠](/problems/7p8L0Z)

</div>

</details>
</div>





