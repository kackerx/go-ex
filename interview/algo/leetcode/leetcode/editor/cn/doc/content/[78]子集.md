<p>给你一个整数数组&nbsp;<code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的<span data-keyword="subset">子集</span>（幂集）。</p>

<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>nums = [1,2,3]
<strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>nums = [0]
<strong>输出：</strong>[[],[0]]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= nums.length &lt;= 10</code></li> 
 <li><code>-10 &lt;= nums[i] &lt;= 10</code></li> 
 <li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li> 
</ul>

<details><summary><strong>Related Topics</strong></summary>位运算 | 数组 | 回溯</details><br>

<div>👍 2356, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/discussions/939' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/images/others/%E5%85%A8%E5%AE%B6%E6%A1%B6.jpg' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：已完成网站教程、网站习题、配套插件中所有多语言代码的校准，解决了之前 chatGPT 翻译可能出错的问题~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=subsets" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

> 本文有视频版：[回溯算法秒杀所有排列/组合/子集问题](https://www.bilibili.com/video/BV1Yt4y1t7dK)

有两种方法解决这道题，这里主要说回溯算法思路，因为比较通用，可以套前文 [回溯算法详解](https://labuladong.online/algo/essential-technique/backtrack-framework/) 写过回溯算法模板。

本质上子集问题就是遍历这样用一棵回溯树：

![](https://labuladong.online/algo/images/子集/1.jpg)

**详细题解：[回溯算法秒杀所有排列/组合/子集问题](https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/)**

</div>

**标签：[回溯算法](https://labuladong.online/algo/)，[数学](https://labuladong.online/algo/)**

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">cpp🟢</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">java🤖</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item active" data-tab-group="default"><div class="highlight">

```cpp
class Solution {
    public:
    vector<vector<int>> res;
    vector<vector<int>> subsets(vector<int>& nums) {
        // 记录走过的路径
        vector<int> track;
        backtrack(nums, 0, track);
        return res;
    }

    void backtrack(vector<int>& nums, int start, vector<int>& track) {
        res.push_back(track);
        for (int i = start; i < nums.size(); i++) {
            // 做选择
            track.push_back(nums[i]);
            // 回溯
            backtrack(nums, i + 1, track);
            // 撤销选择
            track.pop_back();
        }
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
# 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution:
    def __init__(self):
        self.res = []

    def subsets(self, nums: List[int]) -> List[List[int]]:
        # 记录走过的路径
        track = []
        self.backtrack(nums, 0, track)
        return self.res

    def backtrack(self, nums: List[int], start: int, track: List[int]) -> None:
        self.res.append(track[:])
        for i in range(start, len(nums)):
            # 做选择
            track.append(nums[i])
            # 回溯
            self.backtrack(nums, i + 1, track)
            # 撤销选择
            track.pop()
```

</div></div>

<div data-tab-item="java" class="tab-item " data-tab-group="default"><div class="highlight">

```java
// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

class Solution {

    List<List<Integer>> res = new ArrayList<>();
    
    public List<List<Integer>> subsets(int[] nums) {
        // 记录走过的路径
        List<Integer> track = new ArrayList<>();
        backtrack(nums, 0, track);
        return res;
    }

    void backtrack(int[] nums, int start, List<Integer> track) {
        res.add(new ArrayList<>(track));
        for (int i = start; i < nums.length; i++) {
            // 做选择
            track.add(nums[i]);
            // 回溯
            backtrack(nums, i + 1, track);
            // 撤销选择
            track.remove(track.size() - 1);
        }
    }
}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

func subsets(nums []int) [][]int {
    var res [][]int
    var track []int
    backtrack(nums, 0, &track, &res)
    return res
}

// 记录走过的路径
// 回溯算法
func backtrack(nums []int, start int, track *[]int, res *[][]int) {
    // 创建当前路径的副本并添加到结果集中
    temp := make([]int, len(*track))
    copy(temp, *track)
    *res = append(*res, temp)
    
    for i := start; i < len(nums); i++ {
        // 做选择
        *track = append(*track, nums[i])
        // 回溯
        backtrack(nums, i+1, track, res)
        // 撤销选择
        *track = (*track)[:len(*track)-1]
    }
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码已经通过力扣的测试用例，应该可直接成功提交。

var subsets = function(nums) {
    let res = [];
    // 记录走过的路径
    // @visualize status(track)
    var backtrack = function(nums, start, track) {
        res.push([...track]);
        for (let i = start; i < nums.length; i++) {
            // 做选择
            // @visualize choose(nums[i])
            track.push(nums[i]);
            // 回溯
            backtrack(nums, i + 1, track);
            // 撤销选择
            // @visualize unchoose()
            track.pop();
        }
    }
    
    backtrack(nums, 0, []);
    return res;
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>👾👾 算法可视化 👾👾</strong></summary><div id="data_subsets" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_subsets"></div></div>
</details><hr /><br />

**类似题目**：
  - [216. 组合总和 III 🟠](/problems/combination-sum-iii)
  - [39. 组合总和 🟠](/problems/combination-sum)
  - [40. 组合总和 II 🟠](/problems/combination-sum-ii)
  - [46. 全排列 🟠](/problems/permutations)
  - [47. 全排列 II 🟠](/problems/permutations-ii)
  - [77. 组合 🟠](/problems/combinations)
  - [90. 子集 II 🟠](/problems/subsets-ii)
  - [剑指 Offer II 079. 所有子集 🟠](/problems/TVdhkn)
  - [剑指 Offer II 080. 含有 k 个元素的组合 🟠](/problems/uUsW3B)
  - [剑指 Offer II 081. 允许重复选择元素的组合 🟠](/problems/Ygoe9J)
  - [剑指 Offer II 082. 含有重复元素集合的组合 🟠](/problems/4sjJUc)
  - [剑指 Offer II 083. 没有重复元素集合的全排列 🟠](/problems/VvJkup)
  - [剑指 Offer II 084. 含有重复元素集合的全排列 🟠](/problems/7p8L0Z)

</div>

</details>
</div>





