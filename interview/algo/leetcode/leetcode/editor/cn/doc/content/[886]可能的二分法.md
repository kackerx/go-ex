<p>给定一组&nbsp;<code>n</code>&nbsp;人（编号为&nbsp;<code>1, 2, ..., n</code>），&nbsp;我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>

<p>给定整数 <code>n</code>&nbsp;和数组 <code>dislikes</code>&nbsp;，其中&nbsp;<code>dislikes[i] = [a<sub>i</sub>, b<sub>i</sub>]</code>&nbsp;，表示不允许将编号为 <code>a<sub>i</sub></code>&nbsp;和&nbsp;&nbsp;<code>b<sub>i</sub></code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>

<p>&nbsp;</p>

<ol> 
</ol>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 4, dislikes = [[1,2],[1,3],[2,4]]
<strong>输出：</strong>true
<strong>解释：</strong>group1 [1,4], group2 [2,3]
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 3, dislikes = [[1,2],[1,3],[2,3]]
<strong>输出：</strong>false
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
<strong>输出：</strong>false
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul> 
 <li><code>1 &lt;= n &lt;= 2000</code></li> 
 <li><code>0 &lt;= dislikes.length &lt;= 10<sup>4</sup></code></li> 
 <li><code>dislikes[i].length == 2</code></li> 
 <li><code>1 &lt;= dislikes[i][j] &lt;= n</code></li> 
 <li><code>a<sub>i</sub>&nbsp;&lt; b<sub>i</sub></code></li> 
 <li><code>dislikes</code>&nbsp;中每一组都 <strong>不同</strong></li> 
</ul>

<p>&nbsp;</p>

<details><summary><strong>Related Topics</strong></summary>深度优先搜索 | 广度优先搜索 | 并查集 | 图</details><br>

<div>👍 412, 👎 0<span style='float: right;'><span style='color: gray;'><a href='https://github.com/labuladong/fucking-algorithm/issues' target='_blank' style='color: lightgray;text-decoration: underline;'>bug 反馈</a> | <a href='https://labuladong.online/algo/fname.html?fname=jb插件简介' target='_blank' style='color: lightgray;text-decoration: underline;'>使用指南</a> | <a href='https://labuladong.online/algo/' target='_blank' style='color: lightgray;text-decoration: underline;'>更多配套插件</a></span></span></div>

<div id="labuladong"><hr>

**通知：网站新增大量习题，新增排序算法专题及可视化，具体请查看 [网站更新日志](https://labuladong.online/algo/changelog/website/)~**



<p><strong><a href="https://labuladong.online/algo/slug.html?slug=possible-bipartition" target="_blank">⭐️labuladong 题解</a></strong></p>
<details><summary><strong>labuladong 思路</strong></summary>

<div id="labuladong_solution_zh">

## 基本思路

和 [785. 判断二分图](/problems/is-graph-bipartite) 一样，其实这题考察的就是二分图的判定：

如果你把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 `dislikes` 数组就可以构成一幅图；

又因为题目说互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组；

那就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么你按照颜色把这些节点分成两组不就行了嘛。

所以解法就出来了，我们把 `dislikes` 构造成一幅图，然后执行二分图的判定算法即可。

- **详细题解**：
  - [二分图判定算法](https://labuladong.online/algo/data-structure/bipartite-graph/)

</div>

<div id="solution">

## 解法代码



<div class="tab-panel"><div class="tab-nav">
<button data-tab-item="cpp" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">cpp🤖</button>

<button data-tab-item="python" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">python🤖</button>

<button data-tab-item="java" class="tab-nav-button btn active" data-tab-group="default" onclick="switchTab(this)">java🟢</button>

<button data-tab-item="go" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">go🤖</button>

<button data-tab-item="javascript" class="tab-nav-button btn " data-tab-group="default" onclick="switchTab(this)">javascript🤖</button>
</div><div class="tab-content">
<div data-tab-item="cpp" class="tab-item " data-tab-group="default"><div class="highlight">

```cpp
// 注意：cpp 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution {
private:
    bool ok = true;
    vector<bool> color;
    vector<bool> visited;

public:
    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {
        // 图节点编号从 1 开始
        color.resize(n + 1);
        visited.resize(n + 1);
        // 转化成邻接表表示图结构
        vector<vector<int>> graph = buildGraph(n, dislikes);

        for (int v = 1; v <= n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

private:
    // 建图函数
    vector<vector<int>> buildGraph(int n, vector<vector<int>>& dislikes) {
        // 图节点编号为 1...n
        vector<vector<int>> graph(n + 1);
        for (const auto& edge : dislikes) {
            int v = edge[1];
            int w = edge[0];
            // 「无向图」相当于「双向图」
            // v -> w
            graph[v].push_back(w);
            // w -> v
            graph[w].push_back(v);
        }
        return graph;
    }

    // 和之前判定二分图的 traverse 函数完全相同
    void traverse(const vector<vector<int>>& graph, int v) {
        if (!ok) return;
        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }
};
```

</div></div>

<div data-tab-item="python" class="tab-item " data-tab-group="default"><div class="highlight">

```python
# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译。
# 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

class Solution:
    def __init__(self):
        self.ok = True
        self.color = None
        self.visited = None

    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:
        # 图节点编号从 1 开始
        self.color = [False] * (n + 1)
        self.visited = [False] * (n + 1)
        # 转化成邻接表表示图结构
        graph = self.buildGraph(n, dislikes)

        for v in range(1, n + 1):
            if not self.visited[v]:
                self.traverse(graph, v)
        return self.ok

    # 建图函数
    def buildGraph(self, n: int, dislikes: List[List[int]]) -> List[List[int]]:
        # 图节点编号为 1...n
        graph = [[] for _ in range(n + 1)]
        for edge in dislikes:
            v = edge[1]
            w = edge[0]
            # 「无向图」相当于「双向图」
            # v -> w
            graph[v].append(w)
            # w -> v
            graph[w].append(v)
        return graph

    # 和之前判定二分图的 traverse 函数完全相同
    def traverse(self, graph: List[List[int]], v: int):
        if not self.ok:
            return
        self.visited[v] = True
        for w in graph[v]:
            if not self.visited[w]:
                self.color[w] = not self.color[v]
                self.traverse(graph, w)
            else:
                if self.color[w] == self.color[v]:
                    self.ok = False
```

</div></div>

<div data-tab-item="java" class="tab-item active" data-tab-group="default"><div class="highlight">

```java
class Solution {

    private boolean ok = true;
    private boolean[] color;
    private boolean[] visited;

    public boolean possibleBipartition(int n, int[][] dislikes) {
        // 图节点编号从 1 开始
        color = new boolean[n + 1];
        visited = new boolean[n + 1];
        // 转化成邻接表表示图结构
        List<Integer>[] graph = buildGraph(n, dislikes);

        for (int v = 1; v <= n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }

    // 建图函数
    private List<Integer>[] buildGraph(int n, int[][] dislikes) {
        // 图节点编号为 1...n
        List<Integer>[] graph = new LinkedList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : dislikes) {
            int v = edge[1];
            int w = edge[0];
            // 「无向图」相当于「双向图」
            // v -> w
            graph[v].add(w);
            // w -> v
            graph[w].add(v);
        }
        return graph;
    }

    // 和之前判定二分图的 traverse 函数完全相同
    private void traverse(List<Integer>[] graph, int v) {
        if (!ok) return;
        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }

}
```

</div></div>

<div data-tab-item="go" class="tab-item " data-tab-group="default"><div class="highlight">

```go
// 注意：go 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

// possibleBipartition determines if it's possible to bipartition the graph
func possibleBipartition(n int, dislikes [][]int) bool {
    // 图节点编号从 1 开始
    // 转化成邻接表表示图结构
    graph := buildGraph(n, dislikes)
    color := make([]bool, n+1)
    visited := make([]bool, n+1)

    // Try to color the graph
    for v := 1; v <= n; v++ {
        if !visited[v] {
            if !traverse(graph, v, color, visited) {
                return false
            }
        }
    }
    return true
}

// buildGraph converts the edge list to an adjacency list representation of the graph
// 建图函数
func buildGraph(n int, dislikes [][]int) [][]int {
    // 图节点编号为 1...n
    graph := make([][]int, n+1)
    for i := 1; i <= n; i++ {
        graph[i] = make([]int, 0)
    }
    for _, edge := range dislikes {
        v, w := edge[1], edge[0]
        // 「无向图」相当于「双向图」
        graph[v] = append(graph[v], w)
        graph[w] = append(graph[w], v)
    }
    return graph
}

// traverse performs DFS on the graph to check if it can be colored properly
// 和之前判定二分图的 traverse 函数完全相同
func traverse(graph [][]int, v int, color []bool, visited []bool) bool {
    visited[v] = true
    for _, w := range graph[v] {
        if !visited[w] {
            color[w] = !color[v]
            if !traverse(graph, w, color, visited) {
                return false
            }
        } else if color[w] == color[v] {
            return false
        }
    }
    return true
}
```

</div></div>

<div data-tab-item="javascript" class="tab-item " data-tab-group="default"><div class="highlight">

```javascript
// 注意：javascript 代码由 chatGPT🤖 根据我的 java 代码翻译。
// 本代码的正确性已通过力扣验证，如有疑问，可以对照我的 java 代码查看。

var possibleBipartition = function(n, dislikes) {
    let ok = true;
    let color = new Array(n + 1).fill(false);
    let visited = new Array(n + 1).fill(false);

    // 图节点编号从 1 开始
    // 转化成邻接表表示图结构
    let graph = buildGraph(n, dislikes);

    for (let v = 1; v <= n; v++) {
        if (!visited[v]) {
            traverse(graph, v);
        }
    }
    return ok;

    // 建图函数
    function buildGraph(n, dislikes) {
        // 图节点编号为 1...n
        let graph = new Array(n + 1).fill(0).map(() => []);
        for (let i = 1; i <= n; i++) {
            graph[i] = [];
        }
        for (let edge of dislikes) {
            let v = edge[1];
            let w = edge[0];
            // 「无向图」相当于「双向图」
            // v -> w
            graph[v].push(w);
            // w -> v
            graph[w].push(v);
        }
        return graph;
    }

    // 和之前判定二分图的 traverse 函数完全相同
    function traverse(graph, v) {
        if (!ok) return;
        visited[v] = true;
        for (let w of graph[v]) {
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }
};
```

</div></div>
</div></div>

<hr /><details open hint-container details><summary style="font-size: medium"><strong>🎃🎃 算法可视化 🎃🎃</strong></summary><div id="data_possible-bipartition" data="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"></div><div class="resizable aspect-ratio-container" style="height: 100%;">
<div id="iframe_possible-bipartition"></div></div>
</details><hr /><br />

</div>

</details>
</div>

